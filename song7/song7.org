/*
* Notes
** Key
| a  | 0 |
| b  | 1 |
| c# | 2 |
| d  | 3 |
| e  | 4 |
| f# | 5 |
| g# | 6 |

|----+----+----+----+----|
| a  |  9 |  0 |  0 |  1 |
| b  | 11 |  2 |  1 |  2 |
| c# |  1 |  4 |  2 |  3 |
| d  |  2 |  5 |  3 |  4 |
| d# |  3 |  6 | #3 | #4 |
| e  |  4 |  7 |  4 |  5 |
| f  |  5 |  8 | b5 | b6 |
| f# |  6 |  9 |  5 |  6 |
| g  |  7 | 10 | b6 | b7 |
| g# |  8 | 11 |  6 |  7 |
|----+----+----+----+----|


** 
|----+----+----+----+----+----+----+----|
|    |  8 |  9 | 11 |  1 |  2 |  4 |  6 |
|----+----+----+----+----+----+----+----|
|  8 |  0 |  1 |  3 |  5 |  6 |  8 | 10 |
|  9 | 11 |  0 |  2 |  4 |  5 |  7 |  9 |
| 11 |  9 | 10 |  0 |  2 |  3 |  5 |  7 |
|  1 |  7 |  8 | 10 |  0 |  1 |  3 |  5 |
|  2 |  6 |  7 |  9 | 11 |  0 |  2 |  4 |
|  4 |  4 |  5 |  7 |  9 | 10 |  0 |  2 |
|  6 |  2 |  3 |  5 |  7 |  8 | 10 |  0 |
|----+----+----+----+----+----+----+----|

** T-Matrix A Based
|----+----+----+----+----+----+----+----|
|    | 11 |  0 |  2 |  4 |  5 |  7 |  9 |
|----+----+----+----+----+----+----+----|
| 11 |  3 |  4 |  6 |  8 |  9 | 11 |  1 |
|  0 |  2 |  3 |  5 |  7 |  8 | 10 |  0 |
|  2 |  0 |  1 |  3 |  5 |  6 |  8 | 10 |
|  4 | 10 | 11 |  1 |  3 |  4 |  6 |  8 |
|  5 |  9 | 10 |  0 |  2 |  3 |  5 |  7 |
|  7 |  7 |  8 | 10 |  0 |  1 |  3 |  5 |
|  9 |  5 |  6 |  8 | 10 | 11 |  1 |  3 |
|----+----+----+----+----+----+----+----|


* Track Class

// =====================================================================
// MyTrack Class
// =====================================================================

*/

MyTrack {
  var <>notes = nil,     <>synth = nil, <>out = 0,
    <>chan = 0,  <>balance = 0, <>spread = 0,
    <>amp = 1.0, <>transport = nil,
    <>volCC,<>ballCC;

  *new {arg syn,chn = 0, nts = nil;
    ^super.new.init(syn,chn,nts);
  }

  init {arg syn,chn,nts;

    chan = chn;

    if(nts == nil,
      {
	notes = MyNotes.new;
	notes.init;
      });

    synth = syn;
    this.setup();
  }


  setup {

    if(transport != nil,
      {transport.stop;transport = nil; });

    transport = Pbind(\type, \midi,
		      \midiout, synth,
		      \midicmd, \noteOn,
		      \note,  Pfunc.new({notes.freq.next}- 60),
		      \amp, amp,
		      \chan, chan,
		      \sustain, Pfunc.new({notes.duration.next}),
		      \dur, Pfunc.new({notes.wait.next})
		      ).play;

    transport.stop;

    volCC = MIDIdef.cc(\volume, this.ccvolume, 7,chan);

    ballCC.free;
    ballCC = MIDIdef.cc(\pan, this.ccpan,10);
    
  }

  ccvolume {
    arg vol,cc,chan,src;
    vol = vol/127;
    vol.postln;

    synth.amp = vol;

  }

  ccpan {
    arg vol,cc,chan,src;
    vol = (2*(vol/127))-1;

    vol.postln;

    synth.balance = vol;
  }


}




/*
* SuperCollider
*/
** [[file:include/superInit.sc][SuperColliderInit]]
*/

/*
** [[file:include/synths/basic.sc][Basic SynthDef]]
*/
/*
** [[file:include/synths/evenVCO.sc][evenVCO]]
** [[file:include/synths/mono_evenVCO.sc][Mono evenVCO]]
** [[file:include/synths/eCello.sc][eCello]]
 */


/*
** [[file:include/synths/mono_eCello.sc][Mono_eCello]]

** FM

*/
/*
*** Saxaphone
*/

// =====================================================================
// Sad Saxaphone
// =====================================================================

(
SynthDef("sadSax",
	{
		arg out = 0, freq = 110, gate = 0, amp = 0.5, da = 2,hpf = 590,
		attack = 0.5, decay = 2.0, sustain = 0.0, release = 0.2,
		fattack = 0.5,fdecay = 2.0, fsustain = 0.0,
		frelease = 0.1, aoc = 0.7, gain = 1, cutoff = 12200.00,
		bend = 0, spread = 1, balance = 0;

		var env, fenv, op1, op2, op3, op4, op5, op6,
		fb1, fb2, fb3, fb4, fb5, fb6, freq2, tmp,
		sig;

		env  = Env.adsr(attack,decay,sustain,release,curve: 'welch');
		env = EnvGen.kr(env, gate: gate,doneAction:da);

		fenv = Env.adsr(fattack,fdecay,fsustain,frelease,1,'sine');
		fenv = EnvGen.kr(fenv, gate);

		fenv = aoc*(fenv - 1) + 1;
	    freq = {freq * LFNoise2.kr(2.5,0.01,1)}!1;
		
		fb2 = FbNode(1);
		op2 = 0.7*(SinOsc.ar(freq*1.0,fb2, mul: env));
		fb2.write((0.47*Saw.ar(freq)) + op2);

		fb1 = FbNode(1);
		op1 = 0.95*SinOsc.ar(freq*1,(fb1) + (op2), mul: env);
		fb1.write((0.01*Saw.ar(freq)) + op1);

		sig = (op1);
		
	sig = MoogFF.ar
	(
		sig,
		cutoff*fenv,
		gain
	);

		sig = HPF.ar(sig,hpf);

		sig = LeakDC.ar(sig);

		sig = Splay.ar(sig,spread,center:balance);

		Out.ar(out,amp*sig);

}).send(s);

)



/*
**** Setup midi channel Sax
*/
~channel0 = {arg num, vel = 1;
	     var ret;
	     num.postln;
	     ret = Synth("sadSax");
	     ret.set(\freq,num.midicps);
	     ret.set(\gate,1);
	     ret;
};




/*
*** French Horn
*/

SynthDef("frenchHorn",
	  {
	    arg out = 0, freq = 110, gate = 0, amp = 0.250, da = 2,hpf = 20,
	        attack = 0.2, decay = 8.0, sustain = 0.6, release = 0.6,
	        fattack = 0.2,fdecay = 8.0, fsustain = 0.8,frelease = 0.6,
	        aoc = 0.9,gain = 0.7, cutoff = 10200.00,
	        bend = 0, spread = 0, balance = 0;
	
	    var sig, fb1, op1, op2, op3, env, fenv,tmp;

	    env  = Env.adsr(attack,decay,sustain,release,curve: 'welch');
	    env = EnvGen.kr(env, gate: gate,doneAction:da);

	    fenv = Env.adsr(fattack,fdecay,fsustain,frelease,1,'sine');
	    fenv = EnvGen.kr(fenv, gate);
	    fenv = aoc*(fenv - 1) + 1;
	    
		op3 = SinOsc.ar(3*freq);
	    op2 = SinOsc.ar(1*freq);

		  //		tmp = MouseX.kr(0,2).poll;
	    fb1 = FbNode(1);
	    op1 = SinOsc.ar(freq,(op2*1.35) + fb1 + (0.0637501*op3));	  
	    fb1.write(0.3* op1);	  	 
	    sig = env*op1;

		  
	    sig = RLPF.ar
	      (
	       sig,
	       cutoff*fenv,
	       gain
	       );
			  
	    sig = HPF.ar(sig,hpf);
		  
		  //	    sig = FreeVerb.ar(sig,0.33); // fan out...
		  
	    sig = LeakDC.ar(sig);
		  
	    sig = Splay.ar(sig,spread,center:balance);

	    Out.ar(out,amp*sig);
		  
	  }).send(s);



/*
**** Setup midi channel Sax
*/
~channel0 = {arg num, vel = 1;
	     var ret;
	     num.postln;
	     ret = Synth("frenchHorn");
	     ret.set(\freq,num.midicps);
	     ret.set(\gate,1);
	     ret;
};





/*
*** Carriers and Modulators
    Dividing the "fm" synth def into two pieces, a synthdef for a modulator and a 
    synthdef for the carrier, gives more functionality - carrier signals can shaped by two 
    or more modulators.

*/



(

 SynthDef("carrier", { arg inbus = 2, outbus = 0, freq = 440, carPartial = 1, mul = 0.2,
       attack = 0, decay = 0, sustain = 1, release = 0, da = 2;

     var mod,car,env;

     env  = Env.adsr(attack,decay,sustain,release,curve: 'welch');
     
     env = EnvGen.ar(env, gate: gate,doneAction:da);

     mod = In.ar(inbus, 1);

     Out.ar(

	    outbus,

	    SinOsc.ar((freq * carPartial) + mod, 0, mul*env);

	    )

       }).load(s);



 SynthDef("modulator", { arg outbus = 2, freq, modPartial = 1, index = 3,
       attack = 0, decay = 0, sustain = 1, release = 0, da = 2;

     var env;

     env  = Env.adsr(attack,decay,sustain,release,curve: 'welch');
     
     env = EnvGen.ar(env, gate: gate,doneAction:da);

     
     Out.ar(

	    outbus,

	    SinOsc.ar(freq * modPartial, 0, freq) 

	    * 

	    LFNoise1.kr(Rand(3, 6).reciprocal).abs 

	    * 

	    index

	    )

       }).load(s);

)



(

var freq = 440;

// modulators for the left channel

Synth.head(s, "modulator", [\outbus, 2, \freq, freq, \modPartial, 0.649, \index, 2]);

Synth.head(s, "modulator", [\outbus, 2, \freq, freq, \modPartial, 1.683, \index, 2.31]);



// modulators for the right channel

Synth.head(s, "modulator", [\outbus, 4, \freq, freq, \modPartial, 0.729, \index, 1.43]);

Synth.head(s, "modulator", [\outbus, 4, \freq, freq, \modPartial, 2.19, \index, 1.76]);



// left and right channel carriers

Synth.tail(s, "carrier", [\inbus, 2, \outbus, 0, \freq, freq, \carPartial, 1]);

Synth.tail(s, "carrier", [\inbus, 4, \outbus, 1, \freq, freq, \carPartial, 0.97]);

)



(

s.queryAllNodes;

)

*/
/*
** Formants
*/

SynthDef("formant", {
    arg freq = 55, out = 0, amp = 0.5, da = 2, gate = 0,
      spread = 1, balance = 0, hpf = 420,bend = 0,
      attack = 1, decay = 2.50, sustain = 0.4, release = 0.75,
      fattack = 1, fdecay= 2.5,fsustain = 0.4,gain = 1,
      frelease = 0.5, aoc = 0.5, cutoff = 1500.00;

    var sig,sig2, env,fenv,  fb1, freq2;

    env  = Env.adsr(attack,decay,sustain,release);
	
    fenv = Env.adsr(fattack,fdecay,fsustain,frelease);
    fenv = EnvGen.kr(fenv, gate: gate,doneAction:da);
    fenv = aoc*(fenv - 1) + 1;

	//    freq = {freq  * bend.midiratio * LFNoise2.kr(1.0,0.0035,1)}!1;

    fb1 = FbNode(1);
    sig = Formant.ar(freq, freq*3, freq*3.75) + (0.15*fb1);
	
    fb1.write(sig);
	
    sig = sig*EnvGen.kr(env, gate: gate,doneAction:da);
	
    sig = MoogFF.ar
      (
       sig,
       cutoff*fenv,
       gain
       );
	
    sig = HPF.ar(sig,hpf);
	
    sig = LeakDC.ar(sig);
	
    sig = Splay.ar(sig,spread,center:balance);

    Out.ar(out,sig * amp);

  }).send(s);



/*
*** Midi Setup
*/

~channel0 = {arg num, vel = 1;
	     var ret;
	     num.postln;
	     ret = Synth("formant");
	     ret.set(\freq,num.midicps);
	     ret.set(\gate,1);
	     ret;
};


~channel0off = {arg num,vel;^nil;};

** Read Midi file
   SCHEDULED: <2019-05-07 Tue>
 */
/* SÃ©bastien Clara - Janvier 2016


   Import a midi file on 3 Arrays : notes, durations & dates


   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   Put or link this file in a specific directories
   Typical user-specific extension directories :
   OSX:	~/Library/Application Support/SuperCollider/Extensions/
   Linux: 	~/.local/share/SuperCollider/Extensions/

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   Dependence : wslib on Quarks

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   typeMidi => For noteOn & noteOff information.
   But with MuseScore, we don't have. So put typeMidi to 1.
   See the examples below.

*/

ImportMidiFile {
  *new {	arg file, typeMidi=0;

    var midiFile;
    var notes, durees, dates;
    var on, off, datesIndex;

    midiFile = SimpleMIDIFile.read(file);

    if (typeMidi == 0,{
	midiFile.noteEvents.do({ |i| if(i[2] == \noteOn,
	  {on = on.add(i)},
	  {off = off.add(i)})
	      });
      },{
	midiFile.noteEvents.do({ |i| if(i[5] != 0,
	  {on = on.add(i)},
	  {off = off.add(i)})
	      });
      });


    datesIndex = on.collect({|i| i[1]});

    datesIndex.asSet.asArray.sort.do({|date|
	  var indices;
	indices =  datesIndex.indicesOfEqual(date);

	notes = notes.add( indices.collect({|i| on[i][4]}) );

	durees = durees.add( indices.collect({|i|
		var offIndice, duree;
	      offIndice = off.collect({|j| j[4]}).detectIndex({|j| j == on[i][4]});
	      duree = off[offIndice][1] - on[i][1];
	      off.removeAt(offIndice);
	      duree;
	    }) );

	dates = dates.add( date );
      });



    ^[notes, durees, dates];
  }
}

/*
//////////////////////////////////////////////////////////////////////////
//	Usage :

m = SimpleMIDIFile.read("~/Desktop/bwv772.mid");
m.noteEvents.collect({ |i| i.postln }); ""
/*
[ 1, 97, noteOn, 0, 60, 127 ]
[ 1, 265, noteOff, 0, 60, 127 ]
[ 1, 278, noteOn, 2, 62, 127 ]
[ 1, 446, noteOff, 2, 62, 127 ]
*/
// => typeMidi by default

// notes, durations, dates <=
# n, d, t = ImportMidiFile("~/Desktop/bwv772.mid");

n
d
t


m = SimpleMIDIFile.read("~/Desktop/cadence.mid");
m.noteEvents.collect({ |i| i.postln }); ""
					/*
					  [ 0, 0, noteOn, 0, 72, 73 ]
					  [ 0, 479, noteOn, 0, 72, 0 ]
					  [ 0, 480, noteOn, 0, 69, 69 ]
					  [ 0, 959, noteOn, 0, 69, 0 ]
					*/
					// => typeMidi != 0 !!!!!!!!!!!!!!

					// notes, durations, dates <=
# n, d, t = ImportMidiFile("~/Desktop/cadence.mid", 1);

n
d
t

*/
